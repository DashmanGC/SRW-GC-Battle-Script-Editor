/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

/*
 * UserInterfaceBSE.java
 *
 * Created on 15-jul-2014, 18:07:53
 */

package srwgcbattlescripteditor;

import java.awt.Component;
import java.awt.Dimension;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.IOException;
import java.io.RandomAccessFile;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.ImageIcon;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.filechooser.FileNameExtensionFilter;

/**
 *
 * @author Jonatan
 */
public class UserInterfaceBSE extends javax.swing.JFrame {
    ArrayList < ArrayList<BattleLine> > lines;   // Non-repeated lines
    int[] lines_used;   // Every line in the file. This array holds indexes to the previous array.
                        // This way, if there's two or more instances of the same lines in the file, we store it once in lines
                        // and several times the corresponding index in lines_used.

    String lastDirectory = ".";
    String current_file = "";
    String title = "SRW GC Battle Script Editor by Dashman";
    boolean file_loaded = false;
    int current_dialogue = 0;
    
    String font_encoding = "MS932";

    /** Creates new form UserInterfaceBSE */
    public UserInterfaceBSE() {
        initComponents();

        this.setIconImage(new ImageIcon(getClass().getClassLoader().getResource("resources/icons/logo.png")).getImage());

        scrollLines.getVerticalScrollBar().setUnitIncrement(16);

    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        panelNavigation = new javax.swing.JPanel();
        checkSJIS = new javax.swing.JCheckBox();
        buttonPrevious = new javax.swing.JButton();
        labelCurrent = new javax.swing.JLabel();
        buttonNext = new javax.swing.JButton();
        buttonJump = new javax.swing.JButton();
        textfieldJump = new javax.swing.JTextField();
        labelJump = new javax.swing.JLabel();
        scrollLines = new javax.swing.JScrollPane();
        panelLines = new javax.swing.JPanel();
        menubarMain = new javax.swing.JMenuBar();
        menuFile = new javax.swing.JMenu();
        menuitemOpen = new javax.swing.JMenuItem();
        jSeparator1 = new javax.swing.JSeparator();
        menuitemSave = new javax.swing.JMenuItem();
        jSeparator2 = new javax.swing.JSeparator();
        menuitemExit = new javax.swing.JMenuItem();
        menuTools = new javax.swing.JMenu();
        menuitemConvert = new javax.swing.JMenuItem();

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("SRW GC Battle Script Editor by Dashman");
        setResizable(false);

        panelNavigation.setBorder(javax.swing.BorderFactory.createTitledBorder("Navigation"));

        checkSJIS.setFont(new java.awt.Font("Tahoma", 1, 11));
        checkSJIS.setSelected(true);
        checkSJIS.setText("Convert keystrokes to SJIS");
        checkSJIS.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                checkSJISActionPerformed(evt);
            }
        });

        buttonPrevious.setFont(new java.awt.Font("Tahoma", 1, 11));
        buttonPrevious.setForeground(new java.awt.Color(51, 102, 255));
        buttonPrevious.setText("<<");
        buttonPrevious.setEnabled(false);
        buttonPrevious.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonPreviousActionPerformed(evt);
            }
        });

        labelCurrent.setFont(new java.awt.Font("Tahoma", 1, 11));
        labelCurrent.setHorizontalAlignment(javax.swing.SwingConstants.CENTER);
        labelCurrent.setText("0 / 0");
        labelCurrent.setEnabled(false);

        buttonNext.setFont(new java.awt.Font("Tahoma", 1, 11));
        buttonNext.setForeground(new java.awt.Color(51, 102, 255));
        buttonNext.setText(">>");
        buttonNext.setEnabled(false);
        buttonNext.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonNextActionPerformed(evt);
            }
        });

        buttonJump.setFont(new java.awt.Font("Tahoma", 1, 11));
        buttonJump.setText("GO!");
        buttonJump.setEnabled(false);
        buttonJump.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonJumpActionPerformed(evt);
            }
        });

        textfieldJump.setEnabled(false);
        textfieldJump.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                textfieldJumpActionPerformed(evt);
            }
        });

        labelJump.setFont(new java.awt.Font("Tahoma", 1, 11));
        labelJump.setHorizontalAlignment(javax.swing.SwingConstants.RIGHT);
        labelJump.setText("Jump to:");
        labelJump.setEnabled(false);

        javax.swing.GroupLayout panelNavigationLayout = new javax.swing.GroupLayout(panelNavigation);
        panelNavigation.setLayout(panelNavigationLayout);
        panelNavigationLayout.setHorizontalGroup(
            panelNavigationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelNavigationLayout.createSequentialGroup()
                .addContainerGap()
                .addComponent(checkSJIS)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, 105, Short.MAX_VALUE)
                .addComponent(buttonPrevious, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(labelCurrent, javax.swing.GroupLayout.PREFERRED_SIZE, 100, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(18, 18, 18)
                .addComponent(buttonNext, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(80, 80, 80)
                .addComponent(labelJump, javax.swing.GroupLayout.PREFERRED_SIZE, 50, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(textfieldJump, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(buttonJump, javax.swing.GroupLayout.PREFERRED_SIZE, 60, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addContainerGap())
        );
        panelNavigationLayout.setVerticalGroup(
            panelNavigationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(panelNavigationLayout.createSequentialGroup()
                .addContainerGap()
                .addGroup(panelNavigationLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(checkSJIS)
                    .addComponent(buttonJump)
                    .addComponent(textfieldJump, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(labelJump)
                    .addComponent(buttonPrevious)
                    .addComponent(labelCurrent)
                    .addComponent(buttonNext))
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        panelLines.setBackground(new java.awt.Color(204, 204, 204));

        javax.swing.GroupLayout panelLinesLayout = new javax.swing.GroupLayout(panelLines);
        panelLines.setLayout(panelLinesLayout);
        panelLinesLayout.setHorizontalGroup(
            panelLinesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 822, Short.MAX_VALUE)
        );
        panelLinesLayout.setVerticalGroup(
            panelLinesLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 479, Short.MAX_VALUE)
        );

        scrollLines.setViewportView(panelLines);

        menuFile.setText("File");

        menuitemOpen.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        menuitemOpen.setText("Open...");
        menuitemOpen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemOpenActionPerformed(evt);
            }
        });
        menuFile.add(menuitemOpen);
        menuFile.add(jSeparator1);

        menuitemSave.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        menuitemSave.setText("Save as...");
        menuitemSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemSaveActionPerformed(evt);
            }
        });
        menuFile.add(menuitemSave);
        menuFile.add(jSeparator2);

        menuitemExit.setText("Exit");
        menuitemExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemExitActionPerformed(evt);
            }
        });
        menuFile.add(menuitemExit);

        menubarMain.add(menuFile);

        menuTools.setText("Tools");

        menuitemConvert.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_C, java.awt.event.InputEvent.SHIFT_MASK | java.awt.event.InputEvent.CTRL_MASK));
        menuitemConvert.setText("Convert edited text to SJIS");
        menuitemConvert.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                menuitemConvertActionPerformed(evt);
            }
        });
        menuTools.add(menuitemConvert);

        menubarMain.add(menuTools);

        setJMenuBar(menubarMain);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.TRAILING)
                    .addComponent(scrollLines, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, 824, Short.MAX_VALUE)
                    .addComponent(panelNavigation, javax.swing.GroupLayout.Alignment.LEADING, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(panelNavigation, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(scrollLines, javax.swing.GroupLayout.DEFAULT_SIZE, 481, Short.MAX_VALUE)
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void menuitemExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemExitActionPerformed
        // TODO add your handling code here:
        this.dispose();
    }//GEN-LAST:event_menuitemExitActionPerformed

    private void menuitemOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemOpenActionPerformed
        // TODO add your handling code here:
        JFileChooser chooser = new JFileChooser();
        chooser.setCurrentDirectory(new java.io.File(lastDirectory));
        chooser.setDialogTitle("Load BIN file");
        chooser.setFileFilter(new FileNameExtensionFilter("BIN file", "BIN"));

        if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
            openBIN(chooser.getSelectedFile().getAbsolutePath());

            lastDirectory = chooser.getSelectedFile().getPath();

            current_file = chooser.getSelectedFile().getName();

            this.setTitle(current_file + " - " + title);
        }
    }//GEN-LAST:event_menuitemOpenActionPerformed

    private void buttonPreviousActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonPreviousActionPerformed
        // TODO add your handling code here:
        changePage(-1);
    }//GEN-LAST:event_buttonPreviousActionPerformed

    private void buttonNextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonNextActionPerformed
        // TODO add your handling code here:
        changePage(1);
    }//GEN-LAST:event_buttonNextActionPerformed

    private void buttonJumpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonJumpActionPerformed
        // TODO add your handling code here:
        int num_page = Integer.valueOf(textfieldJump.getText());
        jumpTo(num_page - 1);   // We give the illusion that we count pages starting from 1
    }//GEN-LAST:event_buttonJumpActionPerformed

    private void textfieldJumpActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_textfieldJumpActionPerformed
        // TODO add your handling code here:
        buttonJump.doClick();
    }//GEN-LAST:event_textfieldJumpActionPerformed

    private void checkSJISActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_checkSJISActionPerformed
        // TODO add your handling code here:
        Component[] blines = panelLines.getComponents();

        for (int i = 0; i < blines.length; i++){
            PanelBLine bl = (PanelBLine) blines[i];
            bl.setSJIS(checkSJIS.isSelected());
        }
    }//GEN-LAST:event_checkSJISActionPerformed

    private void menuitemConvertActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemConvertActionPerformed
        // TODO add your handling code here:
        Component[] blines = panelLines.getComponents();

        for (int i = 0; i < blines.length; i++){
            PanelBLine bl = (PanelBLine) blines[i];
            bl.convertToSJIS();
        }
    }//GEN-LAST:event_menuitemConvertActionPerformed

    private void menuitemSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_menuitemSaveActionPerformed
        // TODO add your handling code here:
        if (file_loaded){
            JFileChooser chooser = new JFileChooser();
            chooser.setCurrentDirectory(new java.io.File(lastDirectory));
            chooser.setDialogTitle("Save BIN file");
            chooser.setFileFilter(new FileNameExtensionFilter("BIN file", "bin"));
            if (!current_file.isEmpty())
                chooser.setSelectedFile(new File(current_file));

            saveDialogue(); // Save the current dialogue, just in case.

            if (chooser.showOpenDialog(this) == JFileChooser.APPROVE_OPTION){
                current_file = chooser.getSelectedFile().getName();

                saveFile(chooser.getSelectedFile().getAbsolutePath());

                lastDirectory = chooser.getSelectedFile().getPath();
            }
        }
        else{
            JOptionPane.showMessageDialog(null, "No file loaded!",
                    "Error", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_menuitemSaveActionPerformed

    /**
    * @param args the command line arguments
    */
    /*public static void main(String args[]) {
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new UserInterfaceBSE().setVisible(true);
            }
        });
    }*/


    // Takes a 4-byte hex little endian and returns its int value
    // Takes little endian values
    public int byteSeqToInt(byte[] byteSequence){
        if (byteSequence.length != 4)
            return -1;

        int value = 0;
        value += byteSequence[0] & 0xff;
        value += (byteSequence[1] & 0xff) << 8;
        value += (byteSequence[2] & 0xff) << 16;
        value += (byteSequence[3] & 0xff) << 24;
        return value;
    }


    public void openBIN(String filename){
        try{
            RandomAccessFile f = new RandomAccessFile(filename, "r");
            byte[] aux = new byte[4];

            // Read the first 4 bytes and see if it starts with ATMB. Abort if it doesn't.
            f.read(aux);

            if (aux[0] != 'A' || aux[1] != 'T' || aux[2] != 'M' || aux[3] != 'B'){
                f.close();

                JOptionPane.showMessageDialog(null, "Wrong format for bin file:\n" + filename,
                    "Error", JOptionPane.ERROR_MESSAGE);

                return;
            }

            // Read the next 4 bytes to determine the number of entries. Abort if 0.
            f.read(aux);

            int num_entries = byteSeqToInt(aux);

            System.out.println("Number of entries: " + num_entries);

            if (num_entries == 0){
                f.close();

                JOptionPane.showMessageDialog(null, "Number of battle lines in the BIN file: 0",
                    "Error", JOptionPane.ERROR_MESSAGE);

                return;
            }

            byte[] table = new byte[num_entries*4];
            f.read(table);

            // Read the offsets for the entries and save said entries as byte arrays
            byte[][] entries = new byte[num_entries][];
            int start = 0;  // Start of the entry
            int end = 0;    // End of the entry

            int offset = 8;
            f.seek(offset);

            for (int i = 0; i < num_entries; i++){
                f.read(aux);
                offset += 4;
                start = byteSeqToInt(aux);

                if (i < num_entries - 1){
                    f.read(aux);
                    end = byteSeqToInt(aux);
                }
                else
                    end = (int) f.length();

                //System.out.println("Start: " + start + " - End: " + end);

                entries[i] = new byte[end - start];

                f.seek(start);
                f.read(entries[i]);

                f.seek(offset);
            }

            f.close();

            lines_used = new int[num_entries];
            lines = new ArrayList< ArrayList<BattleLine> >();

            // Parse the byte arrays
            // * An entry can have several BattleLines
            for (int i = 0; i < num_entries; i++){
                // Parse the bytes to find battle lines
                ArrayList<BattleLine> abl = new ArrayList<BattleLine>();
                BattleLine bl = null;

                //* We must ignore the first byte in the first entry (it's always 0x0A)
                offset = 0; // We reuse the offset variable
                if (i == 0)
                    offset = 1;

                //System.out.println("Processing entry number: " + i);

                while (offset < entries[i].length){    // Parse a battle line
                    bl = new BattleLine();
                    // First 4 bytes are %f in SJIS
                    // Next 4 bytes are always 00 00 04 00
                    // We ignore these.
                    offset += 8;

                    // Next 4 bytes indicate the portrait
                    aux[0] = (byte) (entries[i][offset] & 0xff);
                    aux[1] = (byte) (entries[i][offset + 1] & 0xff);
                    aux[2] = (byte) (entries[i][offset + 2] & 0xff);
                    aux[3] = (byte) (entries[i][offset + 3] & 0xff);

                    bl.portrait = byteSeqToInt(aux);
                    offset += 4;

                    //System.out.println("Portrait: " + bl.portrait);

                    // Next 8 bytes SHOULD always be 0
                    // We check, just in case...
                    for(int j = 0; j < 8; j++){
                        if (entries[i][offset + j] != 0)
                            System.out.println("Entry " + i + ", byte " + (offset + j) + " is NOT zero.");
                    }
                    offset += 8;

                    // Next 4 bytes indicate the status of the unit during the line
                    // Only the first byte is used, though
                    bl.status = entries[i][offset] & 0xff;

                    //System.out.println("Status: " + bl.status);

                    offset += 4;

                    // If the next 2 bytes are 81 95, we have an extra 12 bytes section
                    if ( entries[i][offset + 1] == (byte) (0x95 & 0xff) ){
                        //System.out.println("Extra part.");

                        byte[] extra = new byte[12];

                        for (int j = 0; j < 12; j++){
                            extra[j] = entries[i][offset + j];
                        }
                        bl.extra = extra;

                        offset += 12;
                    }

                    // Next 2 bytes are 81 93 ( % in SJIS)
                    offset += 2;

                    // Next 2 bytes are the character's ID
                    aux[0] = (byte) (entries[i][offset] & 0xff);
                    aux[1] = (byte) (entries[i][offset + 1] & 0xff);
                    aux[2] = 0;
                    aux[3] = 0;

                    bl.charID = byteSeqToInt(aux);
                    offset += 2;

                    //System.out.println("Character ID: " + bl.charID);

                    // Next 4 bytes are 81 95 82 96 (&v in SJIS)
                    // HOWEVER, there's at least ONE case in which there's no voice and this
                    // section doesn't exist (when Kouji appears in shadows)
                    // Therefore, we have to check if there's a voice section and act accordingly
                    if ( entries[i][offset] == (byte) (0x81 & 0xff)
                            && entries[i][offset + 1] == (byte) (0x95 & 0xff)
                            && entries[i][offset + 2] == (byte) (0x82 & 0xff)
                            && entries[i][offset + 3] == (byte) (0x96 & 0xff) ){
                        offset += 4;

                        // Next 4 bytes are the Voice ID
                        aux[0] = (byte) (entries[i][offset] & 0xff);
                        aux[1] = (byte) (entries[i][offset + 1] & 0xff);
                        aux[2] = (byte) (entries[i][offset + 2] & 0xff);
                        aux[3] = (byte) (entries[i][offset + 3] & 0xff);

                        bl.voice = byteSeqToInt(aux);
                        offset += 4;

                        // Next 2 bytes SHOULD always be 0
                        // We check, just in case...
                        for(int j = 0; j < 2; j++){
                            if (entries[i][offset + j] != 0)
                                System.out.println("Entry " + i + ", byte " + (offset + j) + " is NOT zero.");
                        }
                        offset += 2;
                    }
                    else
                        bl.voice = -1;
                    //System.out.println("Voice: " + bl.voice);

                    // Start of the battle line's text
                    // We have to take all bytes until we run into either:
                    // - 0a 81 95 82 86 (0a followed by &f in SJIS)
                    // - 0a 0a 00 (end of entry)
                    // - 0a 00 (end of file)
                    boolean stop = false;
                    start = offset;
                    
                    while (!stop){
                        if (entries[i][offset] == 0x0a){
                            //System.out.println("Found 0a");
                            if (entries[i][offset + 1] == (byte) (0x81 & 0xff) ){
                                // We've most likely reached the end of a battle line
                                if (entries[i][offset + 2] == (byte) (0x95 & 0xff)
                                        && entries[i][offset + 3] == (byte) (0x82 & 0xff)
                                        && entries[i][offset + 4] == (byte) (0x86 & 0xff)){
                                    stop = true;
                                    end = offset + 1;
                                    //System.out.println("End of line.");
                                }

                                offset++;   // offset points now at the start of the next line
                            }
                            else if (entries[i][offset + 1] == 0x0a ){
                                // We've most likely reached the end of the section
                                if (entries[i][offset + 2] == 0 ){
                                    stop = true;
                                    end = offset + 1;
                                    offset++;
                                    //System.out.println("End of section.");
                                }
                                offset += 2;    // This should make offset equal to the size of the entry
                            }
                            else if (entries[i][offset + 1] == 0 ){
                                // We've most likely reached the end of the file
                                stop = true;
                                end = offset + 1;
                                offset += 2;    // This should make offset equal to the size of the entry
                                //System.out.println("End of file.");
                            }
                            else    // It's just a carriage return
                                offset++;
                        }
                        else    // Normal character
                            offset++;
                    }

                    byte[] text = new byte[end - start];

                    for (int j = 0; j < (end - start); j++){
                        text[j] = entries[i][start + j];
                    }
                    
                    String t = hex2string(text);

                    bl.originalText = t;
                    bl.editText = t;

                    abl.add(bl);    // Add the BattleLine to the array
                }

                // Once we've gathered all the BattleLines in this section, check the ones we already have
                // If there's no other stored section with the same values, add this one to the list
                int position = 0;
                boolean found = false;

                for (int j = 0; j < lines.size() && !found; j++){
                    if (lines.get(j).size() == abl.size()){
                        boolean same = true;
                        //System.out.println("Size A: " + lines.get(j).size() + " Size B: " + abl.size());

                        for (int k = 0; k < lines.get(j).size() && same; k++){
                            bl = abl.get(k);
                            BattleLine bl2 = lines.get(j).get(k);

                            if (bl2.charID != bl.charID
                                    || bl2.portrait != bl.portrait
                                    || bl2.voice != bl.voice
                                    || bl2.status != bl.status){
                                same = false;
                            }
                        }

                        if (same){
                            found = true;
                            position = j;
                            //System.out.println("Entry " + i + " equal to line " + position);
                        }
                    }
                }

                if (!found){
                    position = lines.size();
                    lines.add(abl);
                }

                // Save the number of the list entry in the index array
                lines_used[i] = position;
            }

            System.out.println("Non-repeated lines: " + lines.size());

            // Enable navigation
            file_loaded = true;
            labelCurrent.setEnabled(true);
            labelJump.setEnabled(true);
            textfieldJump.setEnabled(true);
            buttonJump.setEnabled(true);

            // Load first set of lines
            current_dialogue = 0;
            updateControls();
            loadDialogue();

        }catch (IOException ex){
            System.err.print("ERROR: Couldn't read " + filename);
        }
    }


    public String hex2string(byte[] sjis_bytes){
        String sjis_text = "";

        // We have to separate the lines! Each 0a byte means a carriage return
        int start = 0;
        int end = 0;
        int counter = 0;

        while (counter != sjis_bytes.length){
            boolean write = false;
            boolean last = false;

            if (sjis_bytes[counter] == 0x0a){
                end = counter;
                write = true;
            }
            if (counter == sjis_bytes.length - 1){
                //end = counter;
                //write = true;
                last = true;
            }

            if (write){
                try {
                    byte[] line = new byte[end - start];

                    for (int i = 0; i < (end - start); i++)
                        line[i] = sjis_bytes[start + i];

                    sjis_text += new String(line, font_encoding);

                    if (!last)
                        sjis_text += "\n";

                    start = counter + 1;
                } catch (UnsupportedEncodingException ex) {
                    Logger.getLogger(UserInterfaceBSE.class.getName()).log(Level.SEVERE, null, ex);
                }
            }

            counter++;
        }

        return sjis_text;
    }


    public void changePage(int delta){
        saveDialogue();
        current_dialogue += delta;
        loadDialogue();

        updateControls();
    }


    public void jumpTo(int num){
        saveDialogue();

        current_dialogue = num;

        if (num < 0)
            current_dialogue = 0;
        else if (current_dialogue > (lines.size() - 2) )
            current_dialogue = (lines.size() - 1);

        //System.out.println("current: " + current_dialogue + " max: " + script.size());
        loadDialogue();

        updateControls();
    }


    public void updateControls(){
        labelCurrent.setText( (current_dialogue + 1) + " / " + lines.size() );
        buttonPrevious.setEnabled(current_dialogue != 0);
        buttonNext.setEnabled(current_dialogue != lines.size() - 1);
    }


    public void saveDialogue(){
        Component[] blines = panelLines.getComponents();

        for (int i = 0; i < blines.length; i++){
            PanelBLine bl = (PanelBLine) blines[i];
            lines.get(current_dialogue).get(i).editText = bl.getEditText();
        }
    }


    public void loadDialogue(){
        ArrayList<BattleLine> abl = lines.get(current_dialogue);
        panelLines.removeAll();

        int offX = 7;
        int offY = 10;

        int totalHeight = 20;

        for (int i = 0; i < abl.size(); i++){
            BattleLine bl = abl.get(i);

            PanelBLine pbl = new PanelBLine();

            pbl.setCharacter(bl.charID);
            pbl.setPortrait(bl.portrait);
            pbl.setVoice(bl.voice);
            pbl.setStatus(bl.status);
            pbl.setOriginalText(bl.originalText);
            pbl.setEditText(bl.editText);
            
            pbl.writeWidth();

            pbl.setSJIS(checkSJIS.isSelected());

            pbl.setBounds(offX, i*215 + offY, 790, 207);
            //pbl.repaint();
            panelLines.add(pbl);

            totalHeight += 215;
        }

        panelLines.setPreferredSize(new Dimension(panelLines.getWidth() - 20, totalHeight));
        panelLines.repaint();
        scrollLines.repaint();
    }


    public void saveFile(String filename){
        byte[] header = new byte[8];

        int table_size = lines_used.length * 4;
        byte[] table = new byte[table_size];

        header[0] = 'A';
        header[1] = 'T';
        header[2] = 'M';
        header[3] = 'B';

        header[4] = (byte) ( (lines_used.length) & 0xff );
        header[5] = (byte) ( (lines_used.length >> 8) & 0xff );
        header[6] = (byte) ( (lines_used.length >> 16) & 0xff );
        header[7] = (byte) ( (lines_used.length >> 24) & 0xff );

        int offset = table_size + 8;

        byte[] separatorA = new byte[1];
        byte[] separator0 = new byte[1];

        separatorA[0] = 0x0a;
        separator0[0] = 0;

        ByteArrayOutputStream os = new ByteArrayOutputStream( );

        try{
            // Prepare the table and the battle lines' data
            for (int i = 0; i < lines_used.length; i++){
                System.out.println("i: " + i + " - line: " + lines_used[i]);

                // Write offset in the table
                table[i*4] = (byte) ( offset & 0xff );
                table[i*4 + 1] = (byte) ( (offset >> 8)  & 0xff );
                table[i*4 + 2] = (byte) ( (offset >> 16) & 0xff );
                table[i*4 + 3] = (byte) ( (offset >> 24) & 0xff );

                if (i == 0){ // Write this just for the first battle line
                    os.write(separatorA);
                    offset++;
                }

                ArrayList< BattleLine > abl = lines.get(lines_used[i]);
                byte[] aux = null;

                for (int j = 0; j < abl.size(); j++){
                    aux = abl.get(j).getBytes();
                    offset += aux.length;

                    os.write(aux);
                }

                if (i == lines_used.length - 1){
                    os.write(separator0);
                    offset++;   // No real need to update the offset when we reach the end...
                }
                else{
                    os.write(separatorA);
                    os.write(separator0);
                    offset += 2;
                }
            }

            // Write everything into the file
            RandomAccessFile f = new RandomAccessFile(filename, "rw");

            f.write(header);
            f.write(table);
            f.write(os.toByteArray());

            f.close();

            System.out.println("File " + filename + " saved successfully.");    // END

        } catch(IOException ex){
            JOptionPane.showMessageDialog(null, "Could not write file to disk!",
                    "Error", JOptionPane.ERROR_MESSAGE);
            Logger.getLogger(UserInterfaceBSE.class.getName()).log(Level.SEVERE, null, ex);
        }
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton buttonJump;
    private javax.swing.JButton buttonNext;
    private javax.swing.JButton buttonPrevious;
    private javax.swing.JCheckBox checkSJIS;
    private javax.swing.JSeparator jSeparator1;
    private javax.swing.JSeparator jSeparator2;
    private javax.swing.JLabel labelCurrent;
    private javax.swing.JLabel labelJump;
    private javax.swing.JMenu menuFile;
    private javax.swing.JMenu menuTools;
    private javax.swing.JMenuBar menubarMain;
    private javax.swing.JMenuItem menuitemConvert;
    private javax.swing.JMenuItem menuitemExit;
    private javax.swing.JMenuItem menuitemOpen;
    private javax.swing.JMenuItem menuitemSave;
    private javax.swing.JPanel panelLines;
    private javax.swing.JPanel panelNavigation;
    private javax.swing.JScrollPane scrollLines;
    private javax.swing.JTextField textfieldJump;
    // End of variables declaration//GEN-END:variables

}
